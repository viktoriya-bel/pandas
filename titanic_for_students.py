# -*- coding: utf-8 -*-
"""titanic for students.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ytiJoumc6NnjnVF-sG5PABrattiykAFs

## Получение данных

Знакомому формату электронной таблицы Excel в Pandas соответствует структура данных DataFrame. Аналитики обычно называют такие объекты просто DataFrame.
В рабочей практике вы столкнётесь с тем, что данные хранят в файлах разных форматов. Из них самый распространённый – CSV (от англ. Comma-Separated Values, «значения, разделённые запятой»). Каждая строка такого файла представляет собой одну строку таблицы, где данные разделены запятыми. В первой строке собраны заголовки столбцов (если они есть).

Файлы CSV удобнее всего открывать вызовом метода read_csv() из библиотеки Pandas.
Команда для открыия файла имеет вид:
**import pandas as pd
df = pd.read_csv('music_log.csv') # аргумент - путь к файлу**

Теперь все данные из файла можно напечатать на экране командой **print(df)**, но это не всегда нужно делать — не исключено, что таблица огромна и неудобна для изучения. Для знакомства с данными запрашивают несколько строк из начала или конца таблицы, вызывая специальные методы **head()** и **tail()**. По умолчанию **head()** возвращает первые 5 строк набора данных, а метод **tail()** – последние 5 строк. Когда нужно не 5, количество строк передаётся этим методам как аргумент. Например, **head(10)** вернёт первые 10 строк. 

1. Загрузите базу данных по пассажирам “Титаника”.  https://raw.githubusercontent.com/allatambov/Py-programming-3/master/28-05/Titanic.csv.
2. Выведите на печать первые десять строк таблицы.
"""

#Here is your code
import pandas as pd
df = pd.read_csv('https://raw.githubusercontent.com/allatambov/Py-programming-3/master/28-05/Titanic.csv')
df.head(10)

"""## Объект DataFrame

Таблица, которую мы получили, хранится в структуре данных DataFrame. DataFrame — это двумерная структура данных Pandas, где у каждого элемента есть две координаты: по строке и по столбцу. Вы видите две оси, которые формируют объект DataFrame. Первая ось называется индексы, вторая ось — столбцы. По умолчанию индексация в DataFrame начинается с нуля.
Каждая строка — это одно наблюдение, запись об объекте исследования. А столбцы — признаки объектов. В нашем случае одна строка — это информация об одном пассажире, включая класс, фамилию-имя, возраст и т.д.
Подробнее об этом датасете можно почитать здесь http://campus.lakeforest.edu/frank/FILES/MLFfiles/Bio150/Titanic/TitanicMETA.pdf.
Для лучшего понимания данных полезно получить доступ к их описанию. Это либо документация со сведениями о содержании каждого столбца, либо – не самый лучший вариант – рассказ человека, который предоставил вам эту информацию.
Такое описание поможет нам ставить себе корректные задачи.

У DataFrame есть неотъемлемые свойства, значения которых можно запросить. Они называются атрибуты. Например, атрибут columns содержит информацию о названиях столбцов в наборе данных.
**print(df.columns)**
"""

#Here is your code
print(df.columns)

"""В данном случае атрибут **columns** вернул список названий столбцов и сообщил, что каждое из них имеет тип данных **object**.
Вообще типы данных могут быть разные. Для просмотра типа данных каждого столбца лучше всего использовать атрибут **dtypes**.

"""

#Here is your code
print(df.dtypes)

"""Типы данных, о которых сообщают нам атрибуты — это типы данных библиотеки Pandas. Каждому из них соответствует определённый тип данных языка Python.
Так, для **int** таким «двойником» в Pandas будет **int64**. Тип данных object используется, когда данные не подходят ни под одну категорию или соответствуют в Python типу «строка». Вот таблица соответствия типов данных Pandas и Python:
PANDASDTYPE    PYTHON TYPE	     ЗНАЧЕНИЕ
object	          str 	         Строка
int64	          int	         Целые числа
float64	         float	         Вещественные числа
bool	          bool	         Логический тип данных
О размерах таблицы с данными сообщает её атрибут **shape**. В результате получается кортеж (неизменяемый список) из двух чисел: первое – количество строк, второе – количество столбцов.

"""

#Here is your code
print(df.shape)

"""Всю информацию, которую предоставляют разные атрибуты **DataFrame**, можно получить вызовом одного-единственного метода **info()**. Изучив результаты, которые этот метод возвращает, аналитик выбирает тактику дальнейшей работы с таблицей."""

#Here is your code
df.info()

"""Например, здесь в рахных стольцах разное количество элементов с определёнными значениями (non-null). Следовательно, в таблице есть пропущенные значения (null). Прежде чем анализировать такие данные, их нужно обработать. Это одна из самых интересных задач аналитика, и мы поговорим о ней подробнее в следующей теме.

## Задачи
1. Прочитайте файл **student-mat.csv** и сохраните его в переменной **df**. Выведите на экран первые 10 строк таблицы, изучите данныи и описание к таблице. Создайте переменную **shape_table** и сохраните в ней размеры таблицы **student-mat.csv**. Напечатайте на экране размер таблицы в таком виде:
Размер таблицы: ...
2. Сколько наблюдений в наборе данных? В переменной **shape_table** хранится кортеж. Его первый элемент — количество наблюдений, который надо сохранить в переменной **observations_table** (не забывайте, что индексация элементов идёт с 0). Напечатайте на экране ответ в таком виде:
Количество наблюдений: ...
3. Найдите в информации, которую вернул метод **info()**, число наблюдений. Вручную присвойте это число как значение переменной **observations_info_table**.
4. Поскольку в ходе работы аналитик объявляет разные переменные и сохраняет в них добытую разными способами информацию, запутаться очень легко. Именно поэтому необходимо проверять себя и текущие результаты. Сравните полученные результаты в переменных observations_info_table и observations_table. Если значения переменных совпадают, то выведите количество наблюдений и сообщение:
'Решение верно, количество наблюдений равно', observations_table   
Если значения переменных не совпадают, то выведите сообщение:
'Решение неверно, проверьте ещё раз!'
"""

dfStudent = pd.read_csv('student-mat.csv')
print(dfStudent.head(10))
shape_table = dfStudent.shape
print('Размер таблицы: ', shape_table)

observations_table = shape_table[0]
print('Количество наблюдений: ', observations_table)

dfStudent.info()
observations_info_table = 395

if  observations_info_table == observations_table:
    print('Решение верно, количество наблюдений равно: ', observations_table)
else:
    print('Решение неверно, проверьте ещё раз!')

"""## Идексация в DataFrame
К каждой ячейке с данными в **DataFrame** можно обратиться по её индексу и названию столбца. Мы можем получать различные срезы данных в зависимости от того, какой запрос к **DataFrame** мы сформулируем. Этот процесс называется индексация. Для **DataFrame** она проводится разными способами.
Атрибут **loc[строка, столбец]** даёт доступ к элементу по строке и столбцу.

ВИД	                                                  РЕАЛИЗАЦИЯ
Одна ячейка	                                         .loc[7, 'genre']
Один столбец	                                     .loc[:, 'genre']
Несколько столбцов                                   .loc[:, ['genre', 'Artist']]
Несколько столбцов подряд (срез)	                 .loc[:, 'user_id': 'genre']
Одна строка	                                         .loc[1]
Все строки, начиная с заданной	                     .loc[1:]
Все строки до заданной	                             .loc[:3]
Несколько строк подряд (срез)	                     .loc[2:5]

Также вы могли заметить, что запрос к атрибуту loc[] использует квадратные скобки, это напоминает списки в Python. Индексация здесь очень похожа на индексацию списков.
Важное замечание: когда мы используем срезы в списках, то конец среза не включается в результат. А вот атрибут .loc[] тем и выделяется, что включает и начало, и конец среза.
Например, есть список исполнителей:

**artist = ['Marina Rei', 'Stive Morgan','Rixton','Henry Hall & His Gleneagles Hotel Band', 'Andrew Paul Woodworth', 'Pillar Point','Steve Campbell','David Civera','Lumipa Beats', 'Henning Wehland']**
Элементы с 2 по 4 получают запросом:
**print(artist[2:5])**
['Rixton', 'Henry Hall & His Gleneagles Hotel Band', 'Andrew Paul Woodworth'] 
Последним в запросе указан индекс 5 — именно для того, чтобы в срез попал элемент с индексом 4. Запрос на получение со 2 по 4 строки в таблице будет выглядеть вот так:

**print(df.loc[2:4])**
Самые ходовые запросы, которые вам предстоит делать как аналитику данных это запрашивать один столбец, одну строку, диапазон столбцов и диапазон строк.
Для подсчета количества определенных значений в срезе данных в  Pandas для этого есть метод count().
Например, на нужно подсчитать количество детей, младше трех лет на Титанике. Для столбца 'Age' таблицы  такие ячейки отвечают логическому условию df.loc[:,Age']<3. 
Поскольку в указании, какие именно значения считать, нужен логический оператор, такой доступ к значению ячейки называют логическая индексация.


"""

#Here is your code
df.loc[:,'Age']<3
mask = df.loc[:,'Age']<3
childrenUnderThree = df.loc[mask]
print(childrenUnderThree.count())

"""ВИД	                                                  РЕАЛИЗАЦИЯ	                       СОКРАЩЁННАЯ ЗАПИСЬ
Все строки, удовлетворяющие условию	    battle.loc[battle.loc[:,'В'] == 'X']	        battle[battle['В'] == 'X']
Столбец, удовлетворяющий условию	   battle.loc[battle.loc[:,'В'] == 'X']['В']	    battle[battle['В'] == 'X']['В']
Применение метода	              battle.loc[battle.loc[:,'В'] == 'X']['В'].count()	    battle[battle['В'] == 'X']['В'].count()

## Задачи
1. Получите таблицу, состоящую из столбцов Medu и Fedu. Сохраните её в переменной parents. Выведите на экран превые 20 строк.
2. Посчитайте число матерей студентов с высшим образованием. Для этого лучше всего использовать логическое условие parents ['Medu'] == 4. Сохраните результат в переменной mother_hight. Напечатайте ответ на экране в таком виде:
Число матерей с высшим образованием равно ...

3. Теперь посчитайте число отцов студентов с высшим образованием. Допишите в код подсчёт, похожий на предыдущий, только с логическим условием parents ['Fedu'] == 4.. Сохраните результат в переменной father_hight. Напечатайте ответ на экране в таком виде:
Число отцов с высшим образованием равно ...
4. Напишите условную конструкцию, которая сравнивает полученные значения и выводит информацию о победителе в этом бою!))
"""

parents = dfStudent.loc[:,['Medu', 'Fedu']]
parents.head(20)

maskMedu = parents['Medu'] == 4
mother_hight = parents['Medu'].loc[maskMedu]
print('Число матерей с высшим образованием равно', mother_hight.count())

maskFedu = parents['Fedu'] == 4
father_hight = parents['Fedu'].loc[maskFedu]
print('Число отцов с высшим образованием равно', father_hight.count())

if  mother_hight.count() > father_hight.count():
    print('Победили мамы!!! (большее количество по высшему образованию)')
else:
    print('Победили папы!!! (большее количество по высшему образованию)')

"""## Объект Series

В таблице, которую мы рассматривали весь прошлый урок, каждый столбец сам по себе — вовсе не структура данных DataFrame.
"""

type(df) #Таблица всё так же имеет тип DataFrame.

type(df['Age']) #Но если мы возьмём отдельный столбец таблицы, то он представляет собой совсем иную структуру данных — Series.

"""Series — одномерная таблица, и её элементы можно получить по индексу. Каждый индекс — это номер отдельного наблюдения, и поэтому несколько различных Series вместе составляют DataFrame. В Series хранятся данные одного типа. У каждой Series есть имя (Name), информация о количестве данных в столбце (Length) и тип данных, которые хранятся в ней (dtype)."""

print(df['Age'])

"""Индексация в Series аналогична индексации элементов столбца в DataFrame. Давайте рассмотрим на примере. Сохраним столбец Age в переменной age."""

age=df.loc[:,'Age']

#Для получения пятого по индексу элемента укажем 5 в квадратных скобках.
print(age[6])

#Если надо получить диапазон ячеек, запросите атрибут loc с границами среза в квадратных скобках.
print(age.loc[10:20])

"""ВИД	                              РЕАЛИЗАЦИЯ	                                         СОКРАЩЁННАЯ ЗАПИСЬ
Один элемент	                    total_play.loc[7]	                                      total_play[7]
Несколько элементов	                total_play.loc[[5, 7, 10]]	                          total_play[[5, 7, 10]]
Несколько элементов подряд (срез)	total_play.loc[5:10] включая 10                       total_play[5:10] не включая 10
Все элементы, начиная с заданного	total_play.loc[1:]	                                  total_play[1:]
Все элементы до заданного	        total_play.loc[:3] включая 3	                      total_play[:3] не включая 3

Для Series также возможна логическая индексация. Рассмотрим такие примеры. Подсчитаем количествщ выживших мужчин и женщин на корабле.

1. Получим таблицу только с женщинами и сохраним ее в переменной women.
"""

women=df.loc[df['Sex']=='female']
print(women.head(10))

"""Выделим информацию с выжившими женщинами в особую структуру данных. Сохраним столбец Survived таблицы women в переменной women_life"""

women_life=women.loc[:,'Survived']
print(women_life)

"""Обратимся к новой переменной women_life и подсчитаем количество выживших женщин"""

quantity_women=women_life.loc[women_life==1].count()
print('Количество выживших женщин равно', quantity_women)

"""## Задачи
1. Теперь по аналогии создайте Series, где хранятся данные только о выживаемости мужчин. Назовите его men_life и сохраните в нем данные столбца Survived.
2. Обратитесь к созданной переменной для подсчета выживших мужчин. Сохраните результат в переменной quantity_men и напечатайте на экране в виде **Количество выживших женщин равно...**.
3. Для обои полов посчитайте долю выживших в процентах. Разделите количество выживших на общее количество мужчин и женщин. Выведите значения новых переменных в процентах с точностью до одного знака после запятой.
"""

men=df.loc[df['Sex']=='male']
men_life = men.loc[:,'Survived']
print(men_life)

quantity_men = men_life.loc[men_life==1].count()
print('Количество выживших женщин равно', quantity_men)

proportionSurvivorsWomen = quantity_women / women_life.count()
print('Доля выживших женщин', round(proportionSurvivorsWomen, 1))
proportionSurvivorsMen = quantity_men / men_life.count()
print('Доля выживших мужчин', round(proportionSurvivorsMen, 1))